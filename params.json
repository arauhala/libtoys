{"name":"Libtoys","tagline":"Generic C++ microwidgets for UI development (proof of concept)","body":"### Introduction to libtoys\r\n\r\nlibtoys demonstrates an idea of microwidgets, which are simplest possible UI widgets doing exactly one things and nothing more. For example the libtoys library contains following widgets:\r\n\r\n   * sz       - determines the size of the enclosed micro widget\r\n   * split    - splits an area in either x, y or z dimension. \r\n                split is normally constructed by functions lr (left right), \r\n                ud (up down) or fb (front back). \r\n   * lay      - positions a toy up, down, left, middle or in some other \r\n                relative or absolute coordinate.\r\n   * tx       - a simple string\r\n   * rc       - rectangle\r\n   * on_click - consumes a mouse click hitting the microwidget region.\r\n\r\nFor example, these widgets can be used in following way to construct a button (code is C++14):\r\n\r\n```C++\r\nauto quit = \r\n    sz(xy(100, 25),                                // 1. set size\r\n       on_click([](click&){ system::exit(0); },    // 2. exit on click\r\n                fb(lay(mid, tx(\"exit\", f, black)), // 3. text on front middle\r\n                   rc(rgba{200, 200, 200,0})));    // 4. rectangle background\r\n```\r\n\r\nsz determines the component to be 100 pixel wide and 25 pixel high. on_click makes application 'exit' when the component is clicked. lay(mid, x) positions the text in the middle and fb splits the 'space' into foreground and background, where the text (tx) is layouted front and rectangle (rc) is layouted back. \r\n\r\n### Design and capabilities\r\n\r\nWhile libtoys is a proof of concept and simply lacks maturity to support real development, the basic design combines many ideas and values that can be considered valuable. Here the leading idea behind libtoys is minimalism and genericity and it follows strictly the UNIX idea that the system should consist of minimalistic tools doing one thing right, and the power should raise from the way the components are combined. The extreme minimalism brings many benefits: \r\n\r\n* small learning overhead. libtoys contains less than dozen primitives. if it seeks real usage this number will inevitably grow, but not necessarily much.\r\n* the small base of simple but powerful items is easy master. this easiness to master comprehend the powerful tool set is expected to make the programming much more productive and efficient.\r\n* the abstract technical items are forever (e.g. BSD sockets), while more specific services tend to....   \r\n 1. ...not entirely fit the users needs (some widget is inadequate or missing) \r\n 2. ...obsolete as the technology advances or the needs change. \r\n 3. This leads to wide creation of custom UI components, which creation most UI toolkits allow, but do not specially support.\r\n\r\nOther design goals of libtoys have been:\r\n\r\n* Genericity. libtoys can be used to layout and draw 'text' (as demonstrated in unit test cases) as well to treat normal 2D graphics (as demonstrated by the OpenSDL usage). libtoys can likely be ported to curses and used in interactive terminal. \r\n* Declarativeness. You can create diverse custom components and layouts without writing a line of imperative drawing or layouting code.\r\n* Statelessness. All microwidgets are stateless. The statelessness reduces the complexity by lot and eliminates classes of bugs. Statelessness also allows reuse of widget instances. \r\n* Terseness. creating a micro widget component can be done inline and requires 0 class definitions. short names are preferred over more verbose names.\r\n* Minimized overhead. \r\n 1. It is accepted that a traditional widget may consist of dozens of even hundreds of microwidgets. This traditional could mean e.g. hundreds of heap allocations meaning huge overhead over a flat design. \r\n 2. This overhead is avoided by composing the micro widgets compile-time with template magic (enabled by C++14. This allows flattening deep micro widget structure into a single C++ template class. E.g. the 7 microwidget button in previous example has sizeof(quit) 96 bytes and can be entirely allocated in stack meaning 0 heap usage and lighting speed. \r\n 3. This compile-time composition should also flatten and inline the generated template code making the single highly optimized and flat draw & layouting routines for single widget instead of generating routines for all dozens of specialized microwidgets.\r\n\r\nAlso the extreme simplicity, declarativeness, statelessness and terseness are expected to improve productivity. At least this is my own experience having worked with similar UI kit (I created for Java). You can quickly master the simple toolkit and you need to write very little code and care for very few things, which makes things much easier & faster. \r\n\r\nOf course: you cannot actually get much done with the library yet, as it is incomplete. Also solution has its issues like verbose errors for mistakes (because heavy template usage) and there may be potential for badly scaling layouting calculations, because lack of states (all thought compiler may optimize recalculations out when widgets are composed compile-time via templates and the problem can anyway be solved by adding stateful 'cache' microwidgets in deep microwidget structures.). \r\n\r\n### Code sample & screenshot: \r\n\r\nHere's a bigger code sample demonstrating the toolkit. Following example demonstrates...\r\n\r\n1. ...writing a simple interactive UI...\r\n2. ...with a manipulated state (variable c) and a dynamic property (rgbtext) that changes when c is modified \r\n3. ...and how to encapsulate compile-time composed widgets in separate modules via itoy interface and how to use encapsulated widgets.\r\n\r\n```C++#include \"toys/sdl.h\"\r\n#include <sstream>\r\n\r\nusing namespace std;\r\nusing namespace toys;\r\nusing namespace toys::sdl;\r\nusing namespace toys::sdl::vals;\r\n\r\nunique_ptr<itoy> make_radio_button(const font& f, const function<void (bool)>& changed);\r\nunique_ptr<itoy> make_resizing_item();\r\n\r\nint main(int argc, char** argv) {\r\n    // set up infra. sdltoys constructor initializes SDL  \r\n    sdltoys i;\r\n    font f(\"/usr/share/fonts/truetype/freefont/FreeMono.ttf\", 20);\r\n    \r\n    // data used by widgets\r\n    const rgba black{0, 0, 0, 0};   // this is immutable\r\n    rgba c{100, 100, 100, 0};    \t// this is mutable state used by reference\r\n    auto rgbtxt = prop([&c]() {\t\t// this is dynamic state produced by lambda\r\n        std::ostringstream buf;\r\n        buf<<\"r:\"<<int(c.r)<<\",g:\"<<int(c.g)<<\",b:\"<<int(c.b);\r\n        return buf.str();\r\n    });\r\n    \r\n    auto radio = make_radio_button(f, [&c](bool v) { c.g = (v?200:100); });\r\n    auto titledradio = lr(0.5, lay(mid, tx(\"green:\", f, black)), lay(mid, radio.get()));\r\n    \r\n    auto resizing = make_resizing_item();\r\n    \r\n    auto text = lay(mid, tx(rgbtxt, f, black));\r\n    auto moreblue = on_click([&c](click&){c.b+=32; },\r\n                             fb(lay(mid, tx(\"more blue\", f, black)), rc(rgba{200,200,250,0})));\r\n    auto quit = on_click([](click&){ system::exit(0); },\r\n                         fb(lay(mid, tx(\"exit\", f, black)), rc(rgba{200, 200, 200,0})));\r\n    \r\n    auto z = fb(ud(0.33,\r\n                   text,\r\n                   ud(0.5,\r\n                      lr(0.5, titledradio, lay(mid, resizing.get())),\r\n                         lr(0.5, lay(mid, sz(xy(0.67, 0.5), moreblue)),\r\n                                 lay(mid, sz(xy(0.67, 0.5), quit))))),\r\n                rc(std::ref(c)));\r\n\r\n    window<decltype(z)&> wnd(\"foo\", vec(), {400, 400}, z);\r\n    return i.run(&wnd);\r\n}\r\n```\r\n\r\nFunctions make_radio_button and make_resizing are defined in a separate file. \r\nThey demonstrate two different ways how micro widgets can be composed in e\r\nencapsulated way that hides internal types and implementations. The first\r\nway sets up everything in a single function body so that widget state is\r\nsplit into several heap blocks, while the second builds widget in single \r\nheap area, but it requires an additional class.\r\n\r\nThe essential interface for encapsulation is the itoy class that has 3 methods \r\nthat are a) size, b) draw and c) recv. owned_itoy or shared_itoy functions \r\ncan be used to wrap a compile-time composed widget inside itoy interface or\r\nclass can implement the interface directly. \r\n\r\n``` C++\r\n#include \"toys/sdl.h\"\r\n#include <functional>\r\n\r\nusing namespace toys::sdl::vals;\r\nusing namespace toys::sdl;\r\nusing namespace toys;\r\nusing namespace std;\r\n\r\n// following widget does not require separate class definition, but its state gets allocated in heap\r\nunique_ptr<itoy> make_radio_button(const font& f, const function<void (bool)>& changed) {\r\n    shared_ptr<bool> state(new bool(false));\r\n    rgba black{0, 0, 10, 0};\r\n    shared_ptr<itoy> on = shared_itoy(fb(lay(mid, tx(\"on\", f, black)), rc(rgba{150, 250, 150, 0})));\r\n    shared_ptr<itoy> off = shared_itoy(fb(lay(mid, tx(\"off\", f, black)), rc(rgba{250, 150, 150, 0})));\r\n    return\r\n        owned_itoy(\r\n\t    sz(xy(75, 50),\r\n                on_click([state, changed](click&) {*state = !*state; changed(*state);},\r\n                         prop([state, &f, on, off, black] () { \r\n                                  return *state ? on.get() : off.get();\r\n\t\t\t       }))));\r\n}\r\n\r\n// composing a stateful and flat (not split into several memory blocks) widget from stateless\r\n// microwidgets is possible, if a bit clumsy.\r\nauto make_resizing_toy(vec* v) {\r\n    return on_click([v](click& c){*v = (v->x() == 50) ? vec(100, 100) :vec(50,50); },\r\n                    sz([v](vec){return *v;}, rc(rgba{255, 255, 255, 0})));\r\n}\r\nclass resizing_item : public itoy {\r\nprivate:\r\n    vec sz_;\r\n    decltype(make_resizing_toy(0)) toy_;\r\npublic:\r\n    resizing_item() : sz_(50, 50), toy_(make_resizing_toy(&sz_)) {}\r\n    vec size(const vec& size) const                    { return toy_->size(size); };\r\n    void draw(const vec& size, graphics_type& i) const { return toy_->draw(size, i); }\r\n    bool recv(const vec& size, ievent& e)              { return toy_->recv(size, e); }\r\n};\r\nunique_ptr<itoy> make_resizing_item() {\r\n    return unique_ptr<itoy>(new resizing_item());\r\n}\r\n```\r\n\r\n# Author\r\n\r\nI (Antti Rauhala) am a software engineer and data scientist at Futurice, who has a background in systems programming, mobile, machine learning and search. My previous projects are freeform (freeform.sourceforge.net) meta language and re-expression method (libreexp.github.com) that is a new kind of representation learning method.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}